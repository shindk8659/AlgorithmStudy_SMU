# 백준 9095

#  풀이

### 문제

정수 4를 1, 2, 3의 조합으로 나타내는 방법은 총 7가지가 있다.

- 1+1+1+1
- 1+1+2
- 1+2+1
- 2+1+1
- 2+2
- 1+3
- 3+1

정수 n이 주어졌을 때, n을 1,2,3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.

---------

### 입력

첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 11보다 작다. 

------

### 출력

각 테스트 케이스마다, n을 1,2,3의 합으로 나타내는 방법의 수를 출력한다. 

------

### 풀이

다이나믹 프로그래밍

* 큰문제를 작은 문제로 나눠서 푸는 알고리즘으로 다음 두가지 속성을 만족해야함
  - overlapping subproblem
  - optimal substructure 
* 다이나믹 프로그래밍에서 각 문제는 한 번만 풀어야 함
  - optimal substructure -> 같은 문제는 구할 때 마다 정답이 같음
  - 정답을 한 번 구했으면, 정답을 어딘가에 메모해 놓을 것->배열에 저장 (memorization)
* c[n] = c[n-1]+c[n-2]+c[n-3]

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int cnt[12] = { 0 }; // 0<=n<11, 메모를 위한 배열

int plus(int n)
{
	int i;
	int temp = 0;

	if (n == 1)
	{
		cnt[n] = 1;
		return cnt[n];
	}
	if (n == 2)
	{
		cnt[n] = 2;
		return cnt[n];
	}
	if (n == 3)
	{
		cnt[n] = 4;
		return cnt[n];
	}
	
	for (i = 1; i <= 3; i++)
	{

		if (n - i <= 0) break;

		if (cnt[n - i] == 0) // 구한적이 없으면 계산
			cnt[n - i] = plus(n - i);

		cnt[n] += cnt[n - i]; //c[n] = c[n-1]+c[n-2]+c[n-3]
	}
	return cnt[n];
}

int main()
{
	int i;
	int T, n;
	scanf("%d", &T);
	plus(11); // n은 11보다 작다고 했으니 미리 한번에 구해놓기
	for (i = 0; i < T; i++)
	{
		scanf("%d", &n);
		printf("%d\n", cnt[n]);
	}
	return 0;
}

```

