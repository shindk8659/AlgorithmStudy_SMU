# 백준 1463 풀이

### 문제

정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
2. X가 2로 나누어 떨어지면, 2로 나눈다.
3. 1을 뺀다.

정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최소값을 출력하시오.

---------

### 입력

첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 자연수 N이 주어진다. 

------------

### 출력

첫째 줄에 연산을 하는 횟수의 최소값을 출력한다. 

------

### 풀이

다이나믹 프로그래밍

* 큰문제를 작은 문제로 나눠서 푸는 알고리즘으로 다음 두가지 속성을 만족해야함
  - overlapping subproblem
  - optimal substructure 
* 다이나믹 프로그래밍에서 각 문제는 한 번만 풀어야 함
  - optimal substructure -> 같은 문제는 구할 때 마다 정답이 같음
  - 정답을 한 번 구했으면, 정답을 어딘가에 메모해 놓을 것->배열에 저장 (memorization)

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int cnt[1000001] = { 0 };
//n일때 최소 연산 횟수, 0으로 초기화, 입력 범위가 1 ~ 10^6이니깐, 10^6+1만큼 할당
//memorization을 위한 메모

int makeone(int n)
{
	int temp;

	if (n == 1) return 0;
	if (cnt[n] > 0) return cnt[n]; //이미 구한 적이 있는지 체크

	//1 빼기
	cnt[n] = makeone(n - 1) + 1;

	//3 나누기
	if (n % 3 == 0)
	{
		temp = makeone(n / 3) + 1;
		if (cnt[n] > temp) cnt[n] = temp;
	}

	//2 나누기
	if (n % 2 == 0)
	{
		temp = makeone(n / 2) + 1;
		if (cnt[n] > temp) cnt[n] = temp;
	}

	//가장 작은 cnt[n]을 리턴시키기
	return cnt[n];
}


int main()
{
	int N; //입력받을 자연수 
	scanf("%d", &N);

	printf("%d\n", makeone(N));
	return 0;
}

```

