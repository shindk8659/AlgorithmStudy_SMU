# 미로 탐색 문제 

* 문제

  * N×M크기의 배열로 표현되는 미로가 있다.

    | 1    | 0    | 1    | 1    | 1    | 1    |
    | ---- | ---- | ---- | ---- | ---- | ---- |
    | 1    | 0    | 1    | 0    | 1    | 0    |
    | 1    | 0    | 1    | 0    | 1    | 1    |
    | 1    | 1    | 1    | 0    | 1    | 1    |

    미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오.

    위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.

    

* BFS 탐색

  * [BFS 설명 자료](http://sarah950716.tistory.com/13)
  * 그래프 전체를 탐색하는 방법 중의 하나이다.
  * 그래프 전체를 탐색하되, 인접한 노드들을 차례대로 방문 하도록 구현한다.
  * 하나하나 탐색을 할것들을 queue 에 push 하고 탐색을 하면 pop 하여 탐색을 완료 했다는것을 알린다.
  * 미로탐색 문제 에서는 0이 아닌 곳, 지나온곳은 다시 탐색 할 필요없음, 미로 탈출 점까지의 최단거리를 계산해야한다는 조건이 존재한다.
  * 최대 동,서,남,북  4가지로 인접한 노드들을 방문할수있는 그래프로 이해하면 된다.

  

  ___

  ``` c++
  #include<iostream>
  #include<string>
  #include<queue>
  #include <vector>// 사용법좀 알아보자
  
  using namespace std;
  
  class xy{
  public: int x,y;
  };
  
  int main() {
      
      int n, m;
      
      char map[100][100];
      //전체 미로를 받아올 2차원배열
      int sum[100][100];
      // 지금까지 지나온길의 path count를 등록할 2차원배열
      bool check[100][100];
      // 지나온 배열을 true 로 바꾸어 다시 돌아가지 않게 판별하기위한 2차원배열
      int dir[4][2] = { { -1,0 },{ 1,0 },{ 0,-1 },{ 0,1 } };
      //동서남북을 확인하기위한 2차원 배열
      queue<xy> q;
      // xy class 로 이루어진 queue 생성 2차원 배열이기때문에 x,y 값에 따라 노드가 달라지므로 두개를 한번에 판별 해야한다!
  
      
      cin >> n >> m;
      string s = "";
      // 입력되는 미로값들을 한줄씩  string 객체에 넣어 판별하기 위해 넣는다.
      for (int i = 0; i < n; i++) {
          cin >> s;
          for (int j = 0; j < m; j++)
              map[i][j] = s.at(j);
          // string 값이므로 at 함수로 j인덱스에 존재하는 char로된 값을 가져와서 2차원배열 인덱스에 맞게 넣어준다.
          
      }
     
      q.push({0,0});// 첫 시작점인 0,0 을 queue에 push 한다.
      check[0][0] = true;// 지나온 길을 true 로 체크
      sum[0][0] = 1;// 0,0 을 지나왔으므로 1로 을 넣어준다.
      
      while (!q.empty()) {
          
          int x = q.front().x; 
          int y = q.front().y;
          // queue 맨 앞에 있는 노드부터 처리를 해야하므로 front에 있는 x 와 y 인덱스 활용한다.
          q.pop();// 탐색을 했으므로pop 을해준다.
          
          for (int i = 0; i < 4; i++) {
              int nx = x + dir[i][0];
              int ny = y + dir[i][1];
              
      if (nx < 0 || nx >= n || ny < 0 || ny >= m || check[nx][ny] || map[nx][ny] == '0'){
      //판별  다음xy 좌표가 0보다 작거나 받아온 맵 크기보다 클때, 
      //이미 다녀온 곳일때, 가지못하는곳일때 다음 for문으로 진행한다.
                  continue;
                  
              }
              q.push({nx, ny});// 사방면을 확인한후  갈수 있는곳들이 있으면  queue에 push한다.
              check[nx][ny] = true;
              sum[nx][ny] = sum[x][y] + 1
                  // 인덱스도 지나왔으므로 이전 합값에 1을 더하여 저장한다.;
          }
      }
      cout << sum[n - 1][m - 1] << endl; // 배열은 0,0 인덱스에서 시작하므로 nXm 크기의 배열 종착점은
      //n-1 ,m-1 이다. 그러므로 합산 기록 2차원배열의 인덱스 n-1,m-1 에 값이 최단 경로의 값이므로 출력한다.
      return 0;
  }
  
  
  ```

  

  

  

  

  

  

  

  